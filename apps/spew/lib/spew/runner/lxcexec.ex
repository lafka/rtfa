defmodule Spew.Runner.LXCExec do
  @moduledoc """
  Run a LXC Application container using lxc-execute

  The runner uses the PortRunner to actually call `lxc-execute` after
  using Build, OverlayMount and Network pugins to setup some specifics.
  On each `:start` event a configuration will be generated from the
  state provided by the plugins, this configuration will be removed
  on `{:stop, :normal}` events and during cleanup.

  ## Things to consider before using this

    * Depending on your system, LXC might require CAP_SYS_ADMIN rights
      or setuid. It can easily be fixed by adding /usr/bin/lxc-execute *
      to your sudoers. But there are numerous security implications
      for that

    * Everything is still ran with Spew.Runner.Port underneath.
      this communicates over a basic text protocol and things may
      not work exactly as expected
  """

  use Spew.Plugin
  use Spew.Runner

  require Logger

  alias Spew.Instance.Item
  alias Spew.Runner.Port, as: PortRunner

  defmodule LXC do
    defstruct name: nil, # name used by LXC container
              config: [
                {"lxc.cap.drop", [:sys_module, :mknod, :setuid, :net_raw]},
                {"lxc.cap.drop", [:mac_override]}
              ],
              configfile: nil

    @type t :: %__MODULE__{}

    alias __MODULE__

    def set(%LXC{config: cfg} = state, k, nil) do
      %{state | config: Enum.filter(cfg, fn({match, _}) -> k !== match end)}
    end
    def set(%LXC{config: cfg} = state, k, v) do
      %{state | config: [{k,v} | Enum.filter(cfg, fn({match, _}) -> k !== match end)]}
    end

    def append(%LXC{config: cfg} = state, k, v) do
      %{state | config: [{k,v} | cfg]}
    end

    def append_env(%LXC{config: cfg} = state, env) do
      cfg = Enum.reduce env, cfg, fn({k, v}, cfg) ->
        line = "#{k}=#{v}"
        case Enum.find_index(cfg, fn
            {"lxc.environment", match} when match == line -> true
            (_) -> false
          end) do

          nil ->
            [{"lxc.environment", line} | cfg]

          index ->
            # replace non matching
            case Enum.at cfg, index do
              {_, match} when match == line ->
                cfg

              _ ->
                List.replace_at cfg, index, line
            end
        end
      end

      %{state | config: cfg}
    end

    def save_config(%LXC{configfile: file, config: cfg}) do
      cfg = Enum.reverse cfg

      buf = "# generated by #{__MODULE__}\n\n"
      buf = Enum.reduce cfg, buf, fn({k, v}, buf) ->
        v = List.flatten([v]) |> Enum.join " "
        buf <> k <> " = " <> v <> "\n"
      end

      Logger.debug """
      LXCExec.save_config:

      #{file}
      ---
      #{buf}
      ---
      """
      case File.write file, buf do
        :ok ->
          {:ok, file}

        {:error, _err} = res ->
          res
      end
    end
  end


  def capabilities, do: [
    :plugin,
    :command,
    :env,
    :runtime,
    :network
  ]

  def supported? do
    case System.find_executable "lxc-execute" do
      nil -> false
      _bin -> true
    end
  end

  def pid(%Item{} = instance) do
    PortRunner.pid instance
  end

  def run(%Item{ref: ref} = instance, opts) do
    %LXC{name: name} = cfg = instance.plugin[__MODULE__]
      |> LXC.append_env(instance.env)
      |> LXC.set("lxc.rootfs", extract_runtime(instance, opts))
      |> set_network(instance, opts)

    res = prepare_env instance, opts
    case LXC.save_config cfg do
      {:ok, file} ->
        exec = case instance.command do
          "" <> cmd -> Spew.Utils.String.tokenize cmd
          cmd -> cmd
        end

        cmd = maybe_sudo ++ ["lxc-execute", "-n", name, "-f", file, "--" | exec]

        PortRunner.run %{instance | command: cmd}, opts

      {:error, _} = res ->
        res
    end
  rescue e in Exception ->
    {:error, e.message}
  end

  defp prepare_env(%Item{runtime: nil}, opts), do: nil
  defp prepare_env(%Item{} = item, opts) do
    root = extract_runtime item, opts
    executable = System.find_executable("init.lxc")
    initfiles = [executable | Spew.Utils.Executable.ldd executable]

    Logger.debug """
    instance[#{item.ref}: adding init.lxc files to system
      * #{Enum.join(initfiles, "\n\t* ")}
    """

    :ok = File.mkdir_p Path.join(root, "proc")
    :ok = File.mkdir_p Path.join([root, "dev", "shm"])

    untilerr initfiles, nil, fn(file) ->
      case File.mkdir_p p = Path.join(root, Path.dirname(file)) do
        :ok ->
          Logger.debug "copy #{file} -> #{p}"
          File.cp file, Path.join(root, file)

        {:error, e} ->
          {:error, {{:mkdir, e}, {:path, p}}}
      end
    end
  end

  defp untilerr([], ret, _), do: ret
  defp untilerr([e | rest], ret, fun) do
    case fun.(e) do
      :ok -> untilerr rest, ret, fun
      res -> res
    end
  end

  defp extract_runtime(%Item{runtime: nil}, _opts), do: nil
  defp extract_runtime(%Item{runtime: runtime} = instance, _opts) do
    # If it has a runtime it has a overlaymount
    alias Spew.Plugin.Instance.OverlayMount

    %OverlayMount{mountpoint: root} = instance.plugin[OverlayMount]
    root
  end

  defp maybe_sudo do
    case System.get_env("USER") do
      "root" -> []
      _ -> ["sudo"]
    end
  end

  defp macaddr(ref) do
    {:ok, <<a,b,c,d,e,_ :: binary>>} = String.upcase(ref) |> Base.decode16
    [62, a, b, c, d, e]
      |> Enum.map(&Integer.to_string(&1, 16))
      |> Enum.join(":")
      |> String.downcase
  end

  defp set_network(cfg, %Item{network: nil}, _opts), do: cfg
  defp set_network(%LXC{} = cfg, %Item{plugin: plugins} = instance, opts) do
    alias Spew.Plugin.Instance.Network
    alias Spew.Network.Allocation
    alias Spew.Utils.Net.InetAddress

    net = (plugins[Network] || []) 
    unless net[:allocation] do
      raise Exception, message: {:no_allocation, net[:network]}
    end

    %Allocation{addresses: addrs} = net[:allocation]

    netserver = opts[Spew.Network.Server] || net[Spew.Network.Server] || Network.server
    {:ok, network} = Spew.Network.get net[:network], netserver
    {:ok, slice} = Spew.Network.slice net[:slice], netserver

    "net-" <> iface = network.ref
    bridge = slice.iface || network.iface || iface

    cfg = cfg
      |> LXC.append("lxc.network.type", "veth")
      |> LXC.append("lxc.network.flags", "up")
      |> LXC.append("lxc.network.link", bridge)
      |> LXC.append("lxc.network.hwaddr", macaddr(instance.ref))

    cfg = Enum.reduce addrs, cfg, fn
      ({{_,_,_,_} = addr, mask}, cfg) ->
        LXC.append cfg, "lxc.network.ipv4", InetAddress.to_string(addr) <> "/#{mask}"

      ({addr, mask}, cfg) ->
        LXC.append cfg, "lxc.network.ipv6", InetAddress.to_string(addr) <> "/#{mask}"
    end

    # Add gateways
    cfg = Enum.reduce slice.ranges, cfg, fn
      ({{_,_,_,_} = addr, _mask}, cfg) ->
        LXC.append cfg, "lxc.network.ipv4.gateway", InetAddress.to_string(addr)

      ({addr, _mask}, cfg) ->
        LXC.append cfg, "lxc.network.ipv6.gateway", InetAddress.to_string(addr)
    end
  end

  def stop(%Item{} = instance, signal), do: PortRunner.stop(instance, signal)

  # Spew.Plugin callbacks
  @doc """
  Plugin spec

  Dynamically inserts Network and Build plugins if needed
  OverlayMount is always required
  """
  def spec(%Item{network: net, runtime: runtime} = instance) do
    alias Spew.Plugin.Instance.Network
    alias Spew.Plugin.Instance.Build
    alias Spew.Plugin.Instance.OverlayMount
    alias Spew.Runner.Port, as: PortRunner

    build? = match? {:build, _}, runtime
    extra = (net && [Network] || []) ++ (build? && [Build] || [])

    [
      require: [PortRunner, OverlayMount | extra],
      after: [PortRunner, OverlayMount | extra]
    ]
  end

  @doc """
  Plugin init
  """
  def init(%Item{ref: ref} = instance, _plugin, _opts) do
    Logger.debug "instance[#{ref}]: init plugin #{__MODULE__}"

    name = String.replace instance.name || instance.ref, ~r/[^a-zA-Z0-9_-]/, ""

    basedir = Path.join [Application.get_env(:spew, :spewroot), "instance", instance.ref]
    cfgfile = Path.join basedir, "lxc.config"

    {:ok, %LXC{
      name: name,
      config: [{"lxc.utsname", name} | %LXC{}.config],
      configfile: cfgfile}}
  end

  @doc """
  Handle cleanup of self
  """
  def cleanup(%Item{ref: ref}, _state, _opts), do: :ok

  @doc """
  Handle plugin events
  """
  def notify(_instance, state, _ev), do: :ok
end
